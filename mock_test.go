package lastfm

import (
	"fmt"
	"net/http"
	"net/url"
	"os"
	"sort"
	"strings"
)

type MockLastFM struct{}

func (_ *MockLastFM) Get(uri string) (resp *http.Response, err error) {
	u, _ := url.Parse(uri) // always valid: we only call it with URLs generated by url.URL{}.String()
	fn := buildMockFilename(u.Query())
	fh, err := os.Open(fn)

	if err != nil && os.IsNotExist(err) {
		fmt.Fprintln(os.Stderr, "Produce with: curl -o - '"+uri+"' > '"+fn+"'")
		return
	}
	resp = &http.Response{Body: fh} // doQuery only cares about the Body
	return
}

func buildMockFilename(v url.Values) string {
	parts := make([]string, 0, len(v)+1)
	parts = append(parts, v.Get("method"))

	keys := make([]string, 0, len(v)-1)
	for key, _ := range v {
		if key == "method" || key == "api_key" {
			continue
		}
		keys = append(keys, key)

	}
	sort.Strings(keys)

	for _, key := range keys {
		parts = append(parts, strings.Join([]string{key, strings.Replace(strings.Join(v[key], ","), " ", ".", -1)}, "="))
	}
	parts = append(parts, "xml")

	return "fixtures/" + strings.Join(parts, ".")
}

func Mock(lfm LastFM) LastFM {
	lfm.getter = &MockLastFM{}
	return lfm
}
